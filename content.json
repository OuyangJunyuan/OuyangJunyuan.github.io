{"meta":{"title":"Tsunguan' Blog","subtitle":"","description":"stories and life","author":"Auiong Tsunguan","url":"https://ouyangjunyuan.github.io","root":"/"},"pages":[{"title":"","date":"2021-12-11T14:47:37.230Z","updated":"2021-12-11T14:47:37.230Z","comments":true,"path":"404.html","permalink":"https://ouyangjunyuan.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2021-12-11T14:42:12.341Z","updated":"2021-12-11T14:42:12.341Z","comments":false,"path":"about/index.html","permalink":"https://ouyangjunyuan.github.io/about/index.html","excerpt":"","text":"关于我 1998.10.18 破壳~ 2005.09.01 就读于泉州第二中心小学. 虽然不记得发生了什么? 但是好像很快乐 2011.09.01 平凡无奇的就读于泉州第三中学.👴🏻的青春开始了 2014.06.xx 中考运气upup! 考了有史以来最高分 !!! 2014.09.01 就读于泉州第七中学天后宫高中部 2017.06.07 高考运气又upup! 考了有史以来最高分 !!! 2017.08.18 就读于哈尔滨工业大学深圳校区(自动化专业).此时小伙伴还在放暑假而这个b却早早的被军训了QAQ 2018.12.10 Wen Tian Robot 战队成立啦! 认识了一群可爱的小伙伴们😚 !!! 2019.05.14 😍参赛获得18届Robocon国二. 同年高产赛那啥又获得了挑战杯国三 2019.05.14 😍参赛获得19届Robocon国一 2020.10.14 经过三年努力成功保研啦 2021.06.25 获得校优秀毕业论文(设计).毕业啦和小伙伴们不舍道别 2021.08.22 就读于哈尔滨工业大学深圳校区(控制科学与工程学科)nROS(旧NRSL)实验室. 嗑盐小白开始硕士生涯~"},{"title":"所有分类","date":"2021-12-11T14:43:30.913Z","updated":"2021-12-11T14:43:30.909Z","comments":true,"path":"categories/index.html","permalink":"https://ouyangjunyuan.github.io/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2021-12-11T14:46:45.434Z","updated":"2021-12-11T14:46:45.434Z","comments":true,"path":"friends/index.html","permalink":"https://ouyangjunyuan.github.io/friends/index.html","excerpt":"eaaaa","text":"eaaaa emmm"},{"title":"所有标签","date":"2021-12-11T14:44:46.722Z","updated":"2021-12-11T14:44:46.722Z","comments":true,"path":"tags/index.html","permalink":"https://ouyangjunyuan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"GLog使用记录","slug":"GLog使用记录","date":"2021-12-12T15:54:23.000Z","updated":"2021-12-12T15:58:15.890Z","comments":true,"path":"2021/12/12/GLog使用记录/","link":"","permalink":"https://ouyangjunyuan.github.io/2021/12/12/GLog%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","excerpt":"​ GoogleLogging 的使用: 包括安装使用与功能配置.","text":"​ GoogleLogging 的使用: 包括安装使用与功能配置. 下载与安装日志在工程中用来记录程序中间信息,是不可或缺的.我常用的有: log4cpp: 经典款 NanoLog:现代款,速度恐怖 glog: 经典款, 用的比较多. 如果在ros框架内,使用ROS自带的日志也能记录,可能就是功能欠缺了点. glog说不上有什么优点. 在不追求什么多线程异步日志,不追求极致性能的时候无脑用就完事. github 下载, 然后按cmake构建即可. 12345# 注: 最近glog支持modern cmake 写法link上alias即可glog::glogfind_package (glog 0.6.0 REQUIRED)add_executable (myapp main.cpp)target_link_libraries (myapp glog::glog) 使用简单日志条目123456789101112131415161718// 包含 #include &lt;glog/logging.h&gt;TEST(glog, simple_log) &#123; LOG(WARNING) &lt;&lt; &quot;WARNING\\n&quot;; LOG(INFO) &lt;&lt; &quot;INFO\\n&quot;; LOG(WARNING) &lt;&lt; &quot;WARNING\\n&quot;; LOG(ERROR) &lt;&lt; &quot;ERROR\\n&quot;; LOG(FATAL) &lt;&lt; &quot;FATAL\\n&quot;; // FATAL日志会终端程序并打印调用堆栈 VLOG(0) &lt;&lt; &quot;VLOG(0)\\n&quot;; // verbose logging, 级别为info, 可以认为是对info进行细粒度等级控制.&#125;--- 结果:WARNING: Logging before InitGoogleLogging() is written to STDERRW20211212 15:39:10.839241 9219 main.cpp:6] WARNINGI20211212 15:39:10.839362 9219 main.cpp:7] INFOW20211212 15:39:10.839380 9219 main.cpp:8] WARNINGE20211212 15:39:10.839396 9219 main.cpp:9] ERRORF20211212 15:39:10.839416 9219 main.cpp:10] FATAL*** Check failure stack trace: ***[1] 9219 abort (core dumped) ./test_glog 如果ide有特殊支持(如clion)则可以有如下效果: 点击 蓝色文本 调转 到本行日志代码处. 特殊日志条目glog也充分体会了大家的需求, 提供了一些特殊的LOG.下面结合需求介绍几个常用的 LOG_EVERY_N: 当有一个以很高频率(1K)被执行的地方需要输出时, 使用此方法来避免打印满屏的信息使得其他信息被湮没. 123for (int i = 0; i &lt; 2000; i++) &#123; LOG_EVERY_N(WARNING, 1000) &lt;&lt; &quot;LOG_EVERY_N&quot;;&#125; LOG_IF: 常用语当条件不满足时候发出警告.注:LOG_ASSERT(cond) 等价于LOG_IF(FATAL, cond) ; 12LOG_IF(WARNING, when_cond_make_true)&lt;&lt; &quot;LOG_IF\\n&quot;;用于替换if(when_cond_make_true) &#123;LOG(level)&lt;&lt;...;&#125; LOG_FIRST_N: 对前N次进行输出,一般没用到 123for (int i = 0; i &lt; 20; i++) &#123; LOG_FIRST_N(WARNING, 10) &lt;&lt; &quot;LOG_FIRST_N\\n&quot;;&#125; 功能配置如果日志只是能打印在公屏上,那不叫日志(不如用libfmt).日志还需要能:写入日志文件 / 按级筛选信息/ … glog使用自家gflags来进行参数配置, 可以从代码/配置文件/环境变量 中读取配置.具体使用看需求:smile:. 下面将介绍常用配置: 必备刚才的例子都是只在终端上显式,且提示WARNING: Logging before InitGoogleLogging() is written to STDERR 是因为并没有初始化. 下面对glog进行初始化来开启全功能 1234567--- 能拿到进程入口参数时 int main(int argc, char **argv) &#123; google::InitGoogleLogging(argv[0]);&#125;--- 不能拿到进程入口参数时static std::string params;google::InitGoogleLogging(params.c_str()); 日志文件写入设置默认开启文件写入(默认目录为根目录/tmp). 注:glog的输出到文件和输出到终端是可以分别控制的,配置不当可能没显式在终端却已经写入了文件, 此时会让人觉得程序没有执行到所期望的语句. 12345678910111213141516171819202122232425262728293031323334TEST(glog, log_file) &#123; std::string params(&quot;test_glog&quot;); google::InitGoogleLogging(params.c_str()); /** * @brief 设置INFO等级的日志目录和文件名 * @attention 以下各种参数的不同 * 0. 确保&quot;../info/&quot; 中info目录的存在,否则失败. * 1. &quot;../info/&quot; 输出到目录info下,没有指定生成的日志文件名,默认按时间命名为: ../info/20211212-163428.11990 * 2. &quot;../info&quot; 少了末位的&#x27;/&#x27;, 被解释为: ../info20211212-164011.12224 * 3. &quot;../info/base_name 被解释为: ../info/base_name20211212-164011.12224 */ google::SetLogDestination(google::INFO, &quot;../info/base_name&quot;); // 解释为: ../info/base_name.externtion20211212-164309.12362 FLAGS_timestamp_in_logfile_name = false; // 去掉文件名后的时间戳, 可以自己指定其他标志来区分. std::string dir = &quot;../info&quot;, base_name = &quot;base_name&quot;, externtion = &quot;.externtion&quot;; std::string cmd=&quot;mkdir &quot;+ dir; system(cmd.c_str()); //确保&quot;../info/&quot; 中info目录的存在,否则失败. google::SetLogDestination(google::INFO, (dir + &quot;/&quot; + base_name).c_str()); google::SetLogFilenameExtension(externtion.c_str()); // 设置拓展名 /** * @brief 为最近一次生成的日志文件在指定地点生成软链接 * 如下例子解释为生成[INFO日志目录]和[FLAGS_log_link]下都生成[latest.INFO] 链接. * @attention 是用来在快速查看最新INFO日志的方法,避免在INFO日志目录下手动寻找最新. */ FLAGS_log_link = dir + &quot;/../&quot;; // 必须为绝对路径,否则建立失败 std::string log_symlink = &quot;latest&quot;; google::SetLogSymlink(google::INFO, log_symlink.c_str()); LOG(INFO) &lt;&lt; &quot;INFO\\n&quot;;&#125; 此外设置FLAGS_log_prefix = false; 可以使得日志不带前缀. I20211212 17:25:28.392503 15469 main.cpp:37] INFO =&gt; INFO 实例在项目中我按 进程/每天1个文件夹/等级来安排日志,并在外层放置最新一次日志的链接方便查看. 终端(stderr)显式注:stderr没有缓存,会直接打印到终端并显式红色.因此可能其和stdout的执行顺序会颠倒. 1234567891011121314151617181920212223TEST(glog, log_stderr) &#123; //FLAGS_logtostderr=true; // 打开注释则不输出到日志文件,只输出到stderr fprintf(stderr,&quot;before FLAGS_stderrthreshold=0\\n&quot;); LOG(INFO) &lt;&lt; &quot;INFO\\n&quot;; // 未设置FLAGS_stderrthreshold(默认error), 因此此条不输出到终端,但可以输出到日志 LOG(WARNING) &lt;&lt; &quot;WARNING\\n&quot;; // 未设置FLAGS_stderrthreshold(默认为error) 因此此条不输出到终端,但可以输出到日志 LOG(ERROR) &lt;&lt; &quot;ERROR\\n&quot;; // 设置输出到stderr的日志级别限制 大于等于此值级别的日志才能显式在终端.取值[0, 4]. FLAGS_stderrthreshold = 0; fprintf(stderr,&quot;after FLAGS_stderrthreshold=0\\n&quot;); LOG(INFO) &lt;&lt; &quot;INFO\\n&quot;; LOG(WARNING) &lt;&lt; &quot;WARNING\\n&quot;; LOG(ERROR) &lt;&lt; &quot;ERROR\\n&quot;; // 设置彩色stderr FLAGS_colorlogtostderr = true; fprintf(stderr,&quot;after FLAGS_colorlogtostderr=true\\n&quot;); LOG(INFO) &lt;&lt; &quot;INFO\\n&quot;; LOG(WARNING) &lt;&lt; &quot;WARNING\\n&quot;; LOG(ERROR) &lt;&lt; &quot;ERROR\\n&quot;;&#125; 等级过滤能设置等级的一个有3个变量下面一一介绍: FLAGS_v: 设置VLOG等级,VLOG是INFO级别的. 但是对INFO内又划分了级别,可以进行细粒度控制(因为INFO级别用的最多) 1234567891011121314151617TEST(glog, filter) &#123;// FLAGS_stderrthreshold = 0; VLOG(0) &lt;&lt;&quot;VLOG(0)\\n&quot;; VLOG(1) &lt;&lt;&quot;VLOG(1)\\n&quot;; VLOG(2) &lt;&lt;&quot;VLOG(2)\\n&quot;; VLOG(3) &lt;&lt;&quot;VLOG(3)\\n&quot;; VLOG(4) &lt;&lt;&quot;VLOG(4)\\n&quot;; VLOG(5) &lt;&lt;&quot;VLOG(5)\\n&quot;; FLAGS_v = 2; // 只记录 VLOG级别不大于此值的VLOG. VLOG(0) &lt;&lt;&quot;VLOG(0)\\n&quot;; VLOG(1) &lt;&lt;&quot;VLOG(1)\\n&quot;; VLOG(2) &lt;&lt;&quot;VLOG(2)\\n&quot;; VLOG(3) &lt;&lt;&quot;VLOG(3)\\n&quot;; VLOG(4) &lt;&lt;&quot;VLOG(4)\\n&quot;; VLOG(5) &lt;&lt;&quot;VLOG(5)\\n&quot;;&#125; 现象是, 终端无输出(因为没设置FLAGS_stderrthreshold为0,默认只有error级别以上才输出),而日志文件有输出. 此外,还可以对不同源文件指定不同的VLOG级别 google::SetVLOGLevel,上述FLAGS_v=2可以替换为 google::SetVLOGLevel(&quot;main&quot;,2); 现象一致.. FLAGS_stderrthreshold: 上面说过的,设置输出到stderr的级别限制. FLAGS_minloglevel: 同时限制日志和stderror最低输出等级. 123456789101112TEST(glog, filter) &#123; FLAGS_stderrthreshold = 0; fprintf(stderr, &quot;after FLAGS_stderrthreshold=0\\n&quot;); LOG(INFO) &lt;&lt; &quot;INFO\\n&quot;; LOG(WARNING) &lt;&lt; &quot;WARNING\\n&quot;; LOG(ERROR) &lt;&lt; &quot;ERROR\\n&quot;; FLAGS_minloglevel = 2; // 0:INFO 1: WARNING 2:ERROR 3:FATAL fprintf(stderr, &quot;after FLAGS_minloglevel=2\\n&quot;); LOG(INFO) &lt;&lt; &quot;INFO\\n&quot;; LOG(WARNING) &lt;&lt; &quot;WARNING\\n&quot;; LOG(ERROR) &lt;&lt; &quot;ERROR\\n&quot;;&#125; 注:这几个FLAGS之间有覆盖关系. 日志大小此外还提供日志大小的限制, 当硬盘空间不足时停止写入或者当日志大小超过一定大小(MB)后停止写入. 详见:FLAGS_max_log_size和FLAGS_stop_logging_if_full_disk 信号捕捉与遗言glog对常见的进程失败信号进行处理,如常见的SIGABRT/SIGSEGV等. 1234567891011121314151617181920212223242526272829303132TEST(glog, sig) &#123; google::InstallFailureSignalHandler(); int array[1]; array[2] = 0; // overflow&#125;--- 输出到终端如下*** stack smashing detected ***: &lt;unknown&gt; terminated*** Aborted at 1639302205 (unix time) try &quot;date -d @1639302205&quot; if you are using GNU date ***PC: @ 0x0 (unknown)*** SIGABRT (@0x3e800003f7b) received by PID 16251 (TID 0x7fc5925c9e80) from PID 16251; stack trace: *** @ 0x7fc591fc9980 (unknown) @ 0x7fc5912c5fb7 gsignal @ 0x7fc5912c7921 abort @ 0x7fc591310967 (unknown) @ 0x7fc5913bbb61 (unknown) @ 0x7fc5913bbb22 __stack_chk_fail @ 0x55a985bd43a0 glog_sig_Test::TestBody() @ 0x55a985c24bbf testing::internal::HandleSehExceptionsInMethodIfSupported&lt;&gt;() @ 0x55a985c1dbdd testing::internal::HandleExceptionsInMethodIfSupported&lt;&gt;() @ 0x55a985bf47ca testing::Test::Run() @ 0x55a985bf5198 testing::TestInfo::Run() @ 0x55a985bf5a76 testing::TestSuite::Run() @ 0x55a985c04c04 testing::internal::UnitTestImpl::RunAllTests() @ 0x55a985c25ded testing::internal::HandleSehExceptionsInMethodIfSupported&lt;&gt;() @ 0x55a985c1eb97 testing::internal::HandleExceptionsInMethodIfSupported&lt;&gt;() @ 0x55a985c0340e testing::UnitTest::Run() @ 0x55a985c36530 RUN_ALL_TESTS() @ 0x55a985c364bf main @ 0x7fc5912a8bf7 __libc_start_main @ 0x55a985bd3a3a _startProcess finished with exit code 134 (interrupted by signal 6: SIGABRT) 上述只是显式在终端, 如果想将上面的文本加入到日志文件则: 1234567void FailureToLog(const char *data, int size) &#123; char msg[size + 1]; memcpy(msg, data, size); msg[size - 1] = &#x27;\\0&#x27;; msg[size] = &#x27;\\n&#x27;; LOG(ERROR) &lt;&lt; msg;&#125; 则将日志打印到ERROR中. 功能添加小工具配合fmt变量打印 1234567891011121314151617181920212223242526272829303132#include &lt;fmt/format.h&gt;#include &lt;fmt/ranges.h&gt;#include &lt;boost/preprocessor.hpp&gt;#define BOOST_PP_SEQ_FOR_EACH_LOGDEBUG_STR_MACRO(i, ctx, elem) \\ BOOST_PP_STRINGIZE(elem) &quot; = &#123;&#125;. &quot; \\#define BOOST_PP_SEQ_FOR_EACH_LOGDEBUG_STR(seq) BOOST_PP_SEQ_FOR_EACH( \\ BOOST_PP_SEQ_FOR_EACH_LOGDEBUG_STR_MACRO, \\ BOOST_PP_SEQ_SIZE(seq),seq)#define BOOST_PP_SEQ_FOR_EACH_LOGDEBUG_ARGS(seq) BOOST_PP_SEQ_ENUM(seq)#define VLOGF(LEVEL, MODULE, ...) VLOG(LEVEL) &lt;&lt;fmt::format(&quot;[&quot; #MODULE &quot;] &quot;) \\ &lt;&lt; fmt::format(__VA_ARGS__)#define LOGF(LEVEL, MODULE, ...) LOG(LEVEL) &lt;&lt;fmt::format(&quot;[&quot; #MODULE &quot;] &quot;) \\ &lt;&lt; fmt::format(__VA_ARGS__)#define VLOG_DEBUG(LEVEL, MODULE, SEQ) VLOGF(LEVEL,MODULE,BOOST_PP_SEQ_FOR_EACH_LOGDEBUG_STR(SEQ), \\ BOOST_PP_SEQ_FOR_EACH_LOGDEBUG_ARGS(SEQ)) \\ &lt;&lt; fmt::format(&quot;\\n&quot;)#define LOG_DEBUG(LEVEL, MODULE, SEQ) LOGF(LEVEL,MODULE,BOOST_PP_SEQ_FOR_EACH_LOGDEBUG_STR(SEQ), \\ BOOST_PP_SEQ_FOR_EACH_LOGDEBUG_ARGS(SEQ)) \\ &lt;&lt; fmt::format(&quot;\\n&quot;)TEST(glog, utils) &#123; int a = 0, b; std::vector&lt;int&gt; c&#123;1, 2, 3&#125;; LOG_DEBUG(ERROR, glog_utils_test, (a)(b)(c));&#125;---E20211212 17:55:57.852751 17268 main.cpp:93] [glog_utils_test] a = 0. b = 21968. c = [1, 2, 3]. 使能功能想使得glog使能和失能很简单.把等级阈值都设置最高即可. 也可以在glogging.cc内添加 123GLOG_DEFINE_bool(enable, BoolFromEnv(&quot;GOOGLE_ENABLE&quot;, false), &quot;enable glog&quot;); 然后在void LogMessage::SendToLog() EXCLUSIVE_LOCKS_REQUIRED(log_mutex)对if (FLAGS_logtostderr || !IsGoogleLoggingInitialized()) 的两个情况进行修改. 1234567891011121314151617181920212223242526272829303132333435if (FLAGS_logtostderr || !IsGoogleLoggingInitialized()) &#123; if (FLAGS_enable) &#123; ColoredWriteToStderr(data_-&gt;severity_, data_-&gt;message_text_, data_-&gt;num_chars_to_log_); &#125; // this could be protected by a flag if necessary. LogDestination::LogToSinks(data_-&gt;severity_, data_-&gt;fullname_, data_-&gt;basename_, data_-&gt;line_, &amp;data_-&gt;tm_time_, data_-&gt;message_text_ + data_-&gt;num_prefix_chars_, (data_-&gt;num_chars_to_log_ - data_-&gt;num_prefix_chars_ - 1), data_-&gt;usecs_);&#125; else &#123; if (FLAGS_enable) &#123; // log this message to all log files of severity &lt;= severity_ LogDestination::LogToAllLogfiles(data_-&gt;severity_, data_-&gt;timestamp_, data_-&gt;message_text_, data_-&gt;num_chars_to_log_); LogDestination::MaybeLogToStderr(data_-&gt;severity_, data_-&gt;message_text_, data_-&gt;num_chars_to_log_, data_-&gt;num_prefix_chars_); LogDestination::MaybeLogToEmail(data_-&gt;severity_, data_-&gt;message_text_, data_-&gt;num_chars_to_log_); &#125; LogDestination::LogToSinks(data_-&gt;severity_, data_-&gt;fullname_, data_-&gt;basename_, data_-&gt;line_, &amp;data_-&gt;tm_time_, data_-&gt;message_text_ + data_-&gt;num_prefix_chars_, (data_-&gt;num_chars_to_log_ - data_-&gt;num_prefix_chars_ - 1), data_-&gt;usecs_); // NOTE: -1 removes trailing \\n&#125; 然后就可以快乐的和前面一样使用FLAGS_enable进行开关了(记得声明一下对应的flag) 颜色修改修改glogging.cc内static GLogColor SeverityToColor(LogSeverity severity) 这个函数和enum GLogColor 对应的tags.以及修改每个tag对应的颜色.这些颜色都是ansi code, 可以查询对应的.或加入高亮,下划线,闪烁等功能都是可以的. 1234567891011121314151617181920212223static const char *GetAnsiColorCode(GLogColor color) &#123; switch (color) &#123; case COLOR_BLACK: return &quot;0&quot;; case COLOR_RED: return &quot;1&quot;; case COLOR_GREEN: return &quot;2&quot;; case COLOR_YELLOW: return &quot;3&quot;; case COLOR_BLUE: return &quot;4&quot;; case COLOR_PURPLE: return &quot;5&quot;; case COLOR_DARK_GREEN: return &quot;6&quot;; case COLOR_WHITE: return &quot;7&quot;; case COLOR_DEFAULT: return &quot;&quot;; &#125;; return NULL; // stop warning about return type.&#125; 源码与运行流程分析1234567891011121314151617LOG(INFO) &lt;&lt;&quot;123\\n&quot;;=&gt; COMPACT_GOOGLE_LOG_INFO.stream() &lt;&lt;&quot;123\\n&quot;;=&gt;google::LogMessage(__FILE__, __LINE__).stream() &lt;&lt;&quot;123\\n&quot;; 其中stream()返回LogStream(继承于ostream)并将buffer设置为手动管理的.=&gt;调用send_method_ = SendToLog 函数=&gt; 判断是否初始化.进行提示判断是否需要输出到日志或终端stderr判断是否FATAL退出程序和扫尾工作=&gt;LogToAllLogfiles =&gt; MaybeLogToLogfile把每个级别的日志写入对应文件中.MaybeLogToStderr =&gt; 输出到终端stderrColoredWriteToStderr ...MaybeLogToEmail ...","categories":[{"name":"教程","slug":"教程","permalink":"https://ouyangjunyuan.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"库","slug":"教程/库","permalink":"https://ouyangjunyuan.github.io/categories/%E6%95%99%E7%A8%8B/%E5%BA%93/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://ouyangjunyuan.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"C++","slug":"C","permalink":"https://ouyangjunyuan.github.io/tags/C/"},{"name":"库","slug":"库","permalink":"https://ouyangjunyuan.github.io/tags/%E5%BA%93/"}]},{"title":"Hexo + github pages 搭建个人博客","slug":"Hexo-github-pages-搭建个人博客","date":"2021-12-12T15:36:57.000Z","updated":"2021-12-12T15:52:13.124Z","comments":true,"path":"2021/12/12/Hexo-github-pages-搭建个人博客/","link":"","permalink":"https://ouyangjunyuan.github.io/2021/12/12/Hexo-github-pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"​ 快速上手hexo博客框架+volantis主题+github pages部署 搭建个人博客.","text":"​ 快速上手hexo博客框架+volantis主题+github pages部署 搭建个人博客. ​ 适合像我一样,虽然不知道搭个博客干啥(很酷?)(平常记录都贴知乎了),也不会前端那套技术栈的人快速搭一个满足一下自己的好奇心. ​ 几小时内的建设成果(感谢大佬们搭的框架和写的文档). 虽然个人博客/主页搭建有很多文章了,但我还是把自己的过程记录和分享一下. 配置环境 安装nodejs和npm 首先查看nodejs版本 nodejs -v ,如果版本低于10需要升级. curl -sL https://deb.nodesource.com/setup_12.x | bash - 然后update一下 sudo apt-get install -y nodejs sudo apt-get install npm 安装hexo(博客框架?) npm install hexo就安装好了 然后找一个目录作为个人博客的源码仓库.mkdir ~/Blog cd ~ &amp;&amp; hexo init Blog 就开始下载一些依赖并构建博客仓库了. 部署 github上新建一个仓库, 仓库名为用户名.io如OuyangJunyuan.github.io 回到博客仓库~/Blog, 修改其中_config.yaml 找到deploy, 填入github repo. 1234deploy: type: git repo: git@github.com:OuyangJunyuan/OuyangJunyuan.github.io.git branch: master 然后就可以了. hexo文档参考,然后熟悉一下命令,在博客仓库内输入: 1234hexo clean # 清除生成结果hexo g # 生成页面hexo s # 部署到本地hexo d # 部署到远程 此时可以试试hexo g &amp;&amp; hexo s, 访问链接就是生成的结果 主题配置下面开始介绍怎么弄出页面来.首先基于hexo框架的博客有许多开源主题,帮我搭好了框架.帮我们实现了如下的功能: 编写.md -&gt; 写博客 修改.yml -&gt; 修改配置页面 我们选择好看的volantis: 到博客仓库下的_config.yml中修改theme: volantis,然后npm i hexo-theme-volantis 安装主题. 安装完主题后重新 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s,访问连接http://localhost:4000预览一下.好像变得好看了一点??? 博客编写只需要hexo new &#39;my_first_blog&#39; 就可以在~/Blog/source/_post/下生成一个markdown文档. 123456789(dl) ➜ blog hexo new &#x27;my_first_blog&#x27; INFO Validating configINFO ============================================================ Volantis 5.0.0-rc.1 Docs: https://volantis.js.org/ Repo: https://github.com/volantis-x/hexo-theme-volantis/============================================================INFO Created: ~/blog/source/_posts/my-first-blog.md hexo clean &amp;&amp; hexo g &amp;&amp; hexo s,访问连接http://localhost:4000预览一下.就可以看到主页上多了一篇博客. 个性化配置~/Blog/_config.yml中 site title: Hexo # 修改为自己的名字 , 这是网页的标题 favicon: https://s2.loli.net/2021/12/10/qpIiAZe9lFWT75H.png # 网页图标 主页封面复制~Blog/node_modules/hexo-theme-volantis/_config.yml为~/Blog/_config.volantis.yml 然后修改_config.volantis.yml 终点关注background,logo ,title,subtitle,search features 它们分别是 其中icon的图标是font awesome 系列的, 可以到这里查对应icon的id. 12345678910111213141516171819202122cover: height_scheme: full # full, half layout_scheme: search # blank (留白), search (搜索), dock (坞), featured (精选), focus (焦点) display: home: true archive: true others: false # can be written in front-matter &#x27;cover: true&#x27; background: https://s2.loli.net/2021/12/11/P8osRanT5FrtHuC.jpg #https://s2.loli.net/2021/12/10/2iCOIJd1R3uXmfN.jpg logo: https://s2.loli.net/2021/12/10/qpIiAZe9lFWT75H.png title: &#x27;Au1ong&#x27; subtitle: &#x27;「Keep moving.Stay happy!」&#x27; search: &#x27; 你是故意找岔儿是不是😅&#x27; # search bar placeholder features: - name: 文档 icon: fas fa-archive url: archives/ - name: 关于 icon: fas fa-info-circle url: about/ - name: github icon: fab fa-github url: https://github.com/OuyangJunyuan 侧栏个人介绍同样是~/Blog/_config.volantis.yml,需改的地方是sidebar:widget_library:blogger. 如果侧边栏想加入新的东西,可以在widget_library 中添加组件.然后将组件填到for_page 和for_post 列表中,分别对应了主页侧栏和文章侧栏. 123456789101112131415161718192021222324252627282930sidebar: position: right # left right # 主页、分类、归档等独立页面 for_page: [blogger,github,category,tagcloud,webinfo] # 在页面中显示 ，中文逗号会使得后续内容失效 # layout: docs/post 这类文章页面 for_post: [toc] # 在文章中显示 # 侧边栏组件库 widget_library: # --------------------------------------- # blogger info widget blogger: class: blogger display: [desktop, mobile] # [desktop, mobile] 桌面端和手机端都可以看到 avatar: https://s2.loli.net/2021/12/11/A8vVRJM2CdfHOyL.png shape: circle # circle, rectangle url: /about/ title: &#x27;Auiong Tsunguan&#x27; subtitle: &#x27; 躺平平 &amp; 敲代码 &#x27; jinrishici: false # Poetry Today. You can set a string, and it will be displayed when loading fails. social: - icon: fab fa-github url: https://github.com/OuyangJunyuan/ - img: https://s2.loli.net/2021/12/11/91ROkjpEMHvP8he.png url: https://www.zhihu.com/people/ou-yang-jun-yuan/ - icon: fab fa-qq url: mailto:706545330 - icon: fas fa-envelope url: mailto:706545330@qq.com ... 更多由于官方文档写的很清楚了,我就不再意义转发. 其中的标签是主题对markdown的拓展. 可以显示一些更漂亮东西.","categories":[{"name":"教程","slug":"教程","permalink":"https://ouyangjunyuan.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"工具","slug":"教程/工具","permalink":"https://ouyangjunyuan.github.io/categories/%E6%95%99%E7%A8%8B/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://ouyangjunyuan.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"杂项","slug":"杂项","permalink":"https://ouyangjunyuan.github.io/tags/%E6%9D%82%E9%A1%B9/"}]},{"title":"Learn Hexo","slug":"Learn-Hexo","date":"2021-12-10T06:22:19.000Z","updated":"2021-12-12T15:48:38.506Z","comments":true,"path":"2021/12/10/Learn-Hexo/","link":"","permalink":"https://ouyangjunyuan.github.io/2021/12/10/Learn-Hexo/","excerpt":"这是摘要 info 摘要","text":"这是摘要 info 摘要 这是正文 看这个文档https://volantis.js.org/v5/getting-started/ $\\alpha$$$\\beta$$ test markdown pic 🐑🐑 卡通人物1npm install --save hexo-helper-live2d 然后选一个 卡通人物 安装对应包,推荐live2d-widget-model-shizuku,live2d-widget-model-koharu, live2d-widget-model-haruto.预览 1npm install packagename 标签学习参考 可以认为标签是写markdown的一种拓展,可以渲染出更好看和更多的东西 [note info] 这个gallery,也有用,用来展示多个图片 图片描述","categories":[],"tags":[]}],"categories":[{"name":"教程","slug":"教程","permalink":"https://ouyangjunyuan.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"库","slug":"教程/库","permalink":"https://ouyangjunyuan.github.io/categories/%E6%95%99%E7%A8%8B/%E5%BA%93/"},{"name":"工具","slug":"教程/工具","permalink":"https://ouyangjunyuan.github.io/categories/%E6%95%99%E7%A8%8B/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://ouyangjunyuan.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"C++","slug":"C","permalink":"https://ouyangjunyuan.github.io/tags/C/"},{"name":"库","slug":"库","permalink":"https://ouyangjunyuan.github.io/tags/%E5%BA%93/"},{"name":"杂项","slug":"杂项","permalink":"https://ouyangjunyuan.github.io/tags/%E6%9D%82%E9%A1%B9/"}]}